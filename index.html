<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (T·ª± T·ªëi ∆Øu)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Tailwind gray-900 */
            color: #F9FAFB; /* Tailwind gray-50 */
        }
        .btn {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn:active {
            transform: translateY(1px);
        }
        .card-glow-p {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
        .card-glow-b {
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }
        .card-glow-wait {
             box-shadow: 0 0 20px rgba(156, 163, 175, 0.4);
        }

        #bigRoadDisplay {
            display: grid;
            grid-auto-flow: column;
            grid-auto-columns: 2.5rem; /* 40px */
            gap: 2px;
            overflow-x: auto;
            padding: 8px;
        }
        .road-col {
            display: grid;
            grid-auto-rows: 2.5rem; /* 40px */
            gap: 2px;
        }
        .road-item {
            width: 2.5rem; /* 40px */
            height: 2.5rem; /* 40px */
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.125rem; /* 18px */
            color: white;
            animation: fadeIn 0.5s ease;
        }

        .highlight-ref-col { border: 3px solid #60a5fa; /* blue-400 */ }
        .highlight-asym-col { border: 3px solid #f87171; /* red-400 */ }
        .highlight-target-col { border: 3px solid #facc15; /* yellow-400 */ animation: pulse-yellow 1.5s infinite;}
        .highlight-default-ref-col { border: 3px solid #a78bfa; /* violet-400 */ }


        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
         @keyframes pulse-yellow {
            0%, 100% { box-shadow: 0 0 15px rgba(250, 204, 21, 0.4); }
            50% { box-shadow: 0 0 25px rgba(250, 204, 21, 0.9); }
        }

        .session-item.active {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        .session-item.active .text-gray-400 {
            color: #bfdbfe; /* blue-200 */
        }
        .session-item {
            transition: background-color 0.2s ease-in-out;
        }
        
        /* Bar Chart for Method Stats */
        .bar-chart-container {
            display: flex;
            gap: 2px;
            height: 40px; /* TƒÉng chi·ªÅu cao ƒë·ªÉ c·ªôt tr√¥ng r√µ h∆°n */
            align-items: flex-end;
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 4px;
            overflow-x: auto; /* Cho ph√©p cu·ªôn ngang n·∫øu c√≥ nhi·ªÅu k·∫øt qu·∫£ */
            scrollbar-width: thin;
            scrollbar-color: #4b5563 #1f2937;
        }
        /* Th√™m style cho thanh cu·ªôn */
        .bar-chart-container::-webkit-scrollbar {
            height: 4px;
        }
        .bar-chart-container::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .bar-chart-container::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 2px;
        }
        .bar {
            width: 6px; /* Chuy·ªÉn sang ƒë·ªô r·ªông c·ªë ƒë·ªãnh cho m·ªói c·ªôt */
            flex-shrink: 0; /* NgƒÉn c√°c c·ªôt b·ªã co l·∫°i */
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        .bar.win {
            height: 100%;
            background-color: #3b82f6; /* blue-500 */
        }
        .bar.loss {
            height: 40%;
            background-color: #ef4444; /* red-500 */
        }
        /* Styles for highlighting analysis methods */
        .method-highlight-base {
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .current-method-highlight {
            border-color: #facc15; /* yellow-400 */
            box-shadow: 0 0 15px rgba(250, 204, 21, 0.3);
            background-color: rgba(74, 58, 20, 0.3);
        }
        .previous-method-highlight {
            border-color: #9ca3af; /* gray-400 */
            background-color: rgba(107, 114, 128, 0.15);
        }
    </style>
</head>
<body class="p-4 md:p-8">

<div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">

    <!-- Left Column: Input & History -->
    <div class="lg:col-span-2 space-y-6">
        <!-- Header -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">
            <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (T·ª± T·ªëi ∆Øu)</h1>
            <p class="text-gray-400 mt-2">T·ª± ƒê·ªông H·ªçc & ƒêi·ªÅu Ch·ªânh Theo Hi·ªáu Su·∫•t</p>
        </div>

        <!-- Session Management -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2>
            </div>
            <div id="sessionListContainer" class="space-y-1 bg-gray-900/50 p-2 rounded-lg max-h-48 overflow-y-auto mb-4 border border-gray-700">
                <!-- Session list will be dynamically inserted here -->
            </div>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4">
                <button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">‚ûï M·ªõi</button>
                <button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">‚úèÔ∏è ƒê·ªïi T√™n</button>
                <button onclick="deleteCurrentSession()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a Phi√™n</button>
            </div>
             <!-- Import/Export -->
            <div class="flex flex-col sm:flex-row gap-4">
                <button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t D·ªØ Li·ªáu</button>
                <button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p D·ªØ Li·ªáu</button>
                <input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">
            </div>
        </div>

        <!-- Input Section -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£ V√°n Hi·ªán T·∫°i</h2>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl">
                    <span>üë§</span> PLAYER
                </button>
                <button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl">
                    <span>üè¶</span> BANKER
                </button>
            </div>
            <div class="flex gap-4">
                <button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">‚Ü©Ô∏è Ho√†n T√°c</button>
                <button onclick="clearCurrentSessionHistory()" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a L·ªãch S·ª≠</button>
            </div>
        </div>

        <!-- History Display -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2>
                <span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span>
            </div>
            <div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">
                <div id="bigRoadDisplay">
                    <p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Column: Analysis & Stats -->
    <div class="space-y-6">
        <!-- Accuracy Stats -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ Chung (Phi√™n)</h2>
            <div class="space-y-4">
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
                    <span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>
                </div>
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
                    <div>
                        <span id="correctPredictions" class="text-lg font-semibold text-white">0</span>
                        <span class="text-gray-400">/</span>
                        <span id="totalPredictions" class="text-lg font-semibold text-white">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Global Accuracy Stats -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2>
            <div class="space-y-4">
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
                    <span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>
                </div>
                <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                    <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
                    <div>
                        <span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span>
                        <span class="text-gray-400">/</span>
                        <span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Method Stats -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-purple-300">üìä Th·ªëng K√™ Theo M·∫´u BƒêX</h2>
            <div id="methodStatsContainer" class="space-y-4">
                <!-- Stats will be generated here by JS -->
            </div>
        </div>
        
        <!-- Pattern Analysis -->
        <div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg transition-shadow duration-500">
            <h2 class="text-xl font-semibold mb-4 text-yellow-300">üß† Ph√¢n T√≠ch & ƒê·ªÅ Xu·∫•t</h2>
            <div id="analysisResult" class="space-y-4">
                <p class="text-gray-400 text-center py-8">C·∫ßn th√™m d·ªØ li·ªáu ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch...</p>
            </div>
        </div>
    </div>
</div>

<script>
// --- CORE LOGIC: ASYMMETRY ANALYZER V4 ---
class AsymmetryAnalyzer {
    
    historyToColumns(history) {
        if (!history || history.length === 0) return [];
        const columns = [];
        let currentCol = [history[0]];
        for (let i = 1; i < history.length; i++) {
            if (history[i] === history[i-1]) {
                currentCol.push(history[i]);
            } else {
                columns.push(currentCol);
                currentCol = [history[i]];
            }
        }
        columns.push(currentCol);
        return columns;
    }

    areColumnsEqual(col1, col2) {
        if (!col1 || !col2 || col1.length !== col2.length) return false;
        for (let i = 0; i < col1.length; i++) {
            if (col1[i] !== col2[i]) return false;
        }
        return true;
    }
    
    getActivePattern(history) {
        const columns = this.historyToColumns(history);
        if (columns.length < 3) return null;

        for (let i = columns.length - 2; i >= 1; i--) {
            const asymColCandidate = columns[i];
            const refCol = columns[i - 1];

            if (!this.areColumnsEqual(asymColCandidate, refCol)) {
                return {
                    patternType: `${refCol.length}-${asymColCandidate.length}`,
                    refCol: refCol,
                    asymCol: asymColCandidate,
                    targetCol: columns[i + 1],
                    indices: { ref: i - 1, asym: i, target: i + 1 }
                };
            }
        }
        return null; // No asymmetry found
    }

    getPrediction(history, patternStats = {}) {
        const columns = this.historyToColumns(history);
        const opposite = (val) => val === 'P' ? 'B' : 'P';

        // 1. Find the active asymmetry pattern
        const activePattern = this.getActivePattern(history);

        if (activePattern) {
            const { patternType, refCol, targetCol, indices } = activePattern;
            const currentTargetLength = targetCol.length;
            const stats = patternStats[patternType] || { wins: 0, total: 0 };
            const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : -1;

            let standardPrediction;
            let baseRecommendation;
            let logicType;

            if (refCol.length > currentTargetLength) {
                logicType = 'complete';
                let mismatchFound = Array.from({ length: currentTargetLength }).some((_, j) => targetCol[j] !== refCol[j]);
                standardPrediction = mismatchFound ? opposite(refCol[currentTargetLength]) : refCol[currentTargetLength];
                baseRecommendation = mismatchFound ? "B·∫ÆT C·∫¶U B·∫§T ƒê·ªêI X·ª®NG" : "THEO C·∫¶U ƒê·ªêI X·ª®NG";
            } else {
                logicType = 'alternating';
                standardPrediction = opposite(targetCol[0]);
                baseRecommendation = "B·∫∫ C·∫¶U (BƒêX SO LE)";
            }

            let finalPrediction = standardPrediction;
            let finalRecommendation = baseRecommendation;
            let analysisText;

            // Self-optimization logic
            if (winRate !== -1 && winRate < 40 && stats.total >= 3) {
                finalPrediction = opposite(standardPrediction);
                finalRecommendation = `ƒê·∫¢O NG∆Ø·ª¢C (T·ª∑ l·ªá th·∫•p)`;
                analysisText = `M·∫´u ${patternType} c√≥ t·ª∑ l·ªá th·∫Øng th·∫•p (${winRate.toFixed(1)}%), h·ªá th·ªëng ƒë·ªÅ xu·∫•t ng∆∞·ª£c l·∫°i.`;
            } else if (winRate !== -1) {
                analysisText = `Ph√¢n t√≠ch theo M·∫´u ${patternType} (T·ª∑ l·ªá th·∫Øng: ${winRate.toFixed(1)}% - ${stats.wins}/${stats.total}).`;
            } else {
                analysisText = `Ph√¢n t√≠ch theo M·∫´u ${patternType} (M·∫´u m·ªõi, ch∆∞a c√≥ d·ªØ li·ªáu).`;
            }
            
            return {
                prediction: finalPrediction,
                recommendation: finalRecommendation,
                logicType,
                patternType,
                analysisText,
                highlightIndices: indices
            };
        }

        // 2. Fallback to Default Symmetrical
        if (columns.length >= 2) {
            const lastCol = columns[columns.length - 2];
            const targetCol = columns[columns.length - 1];
            if (lastCol.length > targetCol.length) {
                return {
                    prediction: lastCol[targetCol.length],
                    recommendation: "THEO C·∫¶U ƒê·ªêI X·ª®NG (M·∫∂C ƒê·ªäNH)",
                    logicType: 'default',
                    analysisText: "Kh√¥ng t√¨m th·∫•y ƒëi·ªÉm g√£y BƒêX. D·ª± ƒëo√°n c·∫ßu ƒë·ªëi x·ª©ng s·∫Ω ti·∫øp di·ªÖn.",
                    highlightIndices: { defaultRef: columns.length - 2, target: columns.length - 1 }
                };
            }
        }
        
        return {
            prediction: null,
            analysisText: "Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch.",
            highlightIndices: {}
        };
    }
}

// --- GLOBAL STATE ---
let state = {
    currentSessionId: null,
    sessions: {},
    analyzer: new AsymmetryAnalyzer(),
};

// --- STATS CALCULATION ---
function getPredictionStats(predictions) {
    const total = predictions.length;
    if (total === 0) return { rate: 0, correct: 0, total: 0 };
    const correct = predictions.filter(p => p.predicted === p.actual).length;
    return { rate: (correct / total) * 100, correct, total };
}

// --- UI UPDATE FUNCTIONS ---
function updateBigRoadUI() {
    const history = state.sessions[state.currentSessionId]?.history || [];
    const patternStats = state.sessions[state.currentSessionId]?.patternStats || {};
    const roadDiv = document.getElementById('bigRoadDisplay');
    document.getElementById('totalGames').textContent = history.length;

    if (history.length === 0) {
        roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>';
        roadDiv.style.display = 'block';
        return;
    }
    roadDiv.style.display = 'grid';
    roadDiv.innerHTML = '';
    
    const analysisResult = state.analyzer.getPrediction(history, patternStats);
    const columns = state.analyzer.historyToColumns(history);

    columns.forEach((colData, colIndex) => {
        const colDiv = document.createElement('div');
        colDiv.className = 'road-col';
        
        let highlightClass = '';
        if (analysisResult.highlightIndices) {
            const { ref, asym, target, defaultRef } = analysisResult.highlightIndices;
            if (colIndex === ref) highlightClass = 'highlight-ref-col';
            else if (colIndex === asym) highlightClass = 'highlight-asym-col';
            else if (colIndex === target) highlightClass = 'highlight-target-col';
            else if (colIndex === defaultRef) highlightClass = 'highlight-default-ref-col';
        }

        colData.forEach(item => {
            const itemDiv = document.createElement('div');
            const bgColor = item === 'P' ? 'bg-blue-600' : 'bg-red-600';
            itemDiv.className = `road-item ${bgColor} ${highlightClass}`;
            itemDiv.textContent = item;
            colDiv.appendChild(itemDiv);
        });
        roadDiv.appendChild(colDiv);
    });

    roadDiv.scrollLeft = roadDiv.scrollWidth;
}

function updateAccuracyUI() {
    const predictions = state.sessions[state.currentSessionId]?.predictions || [];
    const stats = getPredictionStats(predictions);
    document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
    document.getElementById('correctPredictions').textContent = stats.correct;
    document.getElementById('totalPredictions').textContent = stats.total;
}

function updateGlobalAccuracyUI() {
    const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);
    const stats = getPredictionStats(allPredictions);
    document.getElementById('globalAccuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
    document.getElementById('globalCorrectPredictions').textContent = stats.correct;
    document.getElementById('globalTotalPredictions').textContent = stats.total;
}

function updateAnalysisUI() {
    const session = state.sessions[state.currentSessionId] || { history: [], patternStats: {} };
    const result = state.analyzer.getPrediction(session.history, session.patternStats);
    
    const analysisResultDiv = document.getElementById('analysisResult');
    const analysisCard = document.getElementById('analysis-card');
    analysisCard.classList.remove('card-glow-p', 'card-glow-b', 'card-glow-wait');

    if (result.prediction) {
        const predictionColor = result.prediction === 'P' ? 'text-blue-400' : 'text-red-400';
        const borderColor = result.prediction === 'P' ? 'border-blue-500' : 'border-red-500';

        analysisResultDiv.innerHTML = `
            <div class="bg-gray-700 p-4 rounded-lg">
                <p class="text-gray-300 whitespace-pre-wrap">${result.analysisText}</p>
            </div>
            <div class="text-center bg-gray-900 py-6 rounded-lg border-2 ${borderColor}">
                <p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t:</p>
                <p class="text-3xl font-extrabold ${predictionColor}">${result.recommendation}</p>
                <p class="text-4xl font-bold mt-2">${result.prediction === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>
            </div>
        `;
        analysisCard.classList.add(result.prediction === 'P' ? 'card-glow-p' : 'card-glow-b');
    } else {
        analysisResultDiv.innerHTML = `<p class="text-gray-400 text-center py-8 whitespace-pre-wrap">${result.analysisText}</p>`;
        analysisCard.classList.add('card-glow-wait');
    }
}

function updatePatternStatsUI() {
    const container = document.getElementById('methodStatsContainer');
    const session = state.sessions[state.currentSessionId];

    if (!session) {
        container.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu.</p>';
        return;
    }

    const { predictions = [], patternStats = {}, history = [] } = session;
    const currentPatternInfo = state.analyzer.getPrediction(history, patternStats);
    const currentPatternType = currentPatternInfo.patternType;
    const prevPrediction = predictions[predictions.length - 1];
    const previousPatternType = prevPrediction ? prevPrediction.patternType : null;

    if (Object.keys(patternStats).length === 0) {
        container.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ m·∫´u BƒêX n√†o ƒë∆∞·ª£c ghi nh·∫≠n.</p>';
        return;
    }

    let html = '';
    const sortedPatterns = Object.keys(patternStats).sort();

    for (const key of sortedPatterns) {
        const { wins, total } = patternStats[key];
        const rate = total > 0 ? (wins / total * 100) : 0;
        
        let highlightClass = 'method-highlight-base';
        let badgeHtml = '';

        if (key === currentPatternType) {
            highlightClass += ' current-method-highlight';
            badgeHtml = `<span class="text-xs font-bold bg-yellow-400 text-gray-900 px-2 py-0.5 rounded-full absolute -top-2 -right-2 transform transition-all" title="Ph∆∞∆°ng ph√°p ƒëang ƒë∆∞·ª£c √°p d·ª•ng cho ƒë·ªÅ xu·∫•t hi·ªán t·∫°i">Hi·ªán t·∫°i</span>`;
        } else if (key === previousPatternType && key !== currentPatternType) {
            highlightClass += ' previous-method-highlight';
            badgeHtml = `<span class="text-xs font-bold bg-gray-400 text-gray-900 px-2 py-0.5 rounded-full absolute -top-2 -right-2 transform transition-all" title="Ph∆∞∆°ng ph√°p ƒë√£ ƒë∆∞·ª£c d√πng cho v√°n tr∆∞·ªõc">V√°n tr∆∞·ªõc</span>`;
        }
        
        let chartHtml = '<div class="bar-chart-container mt-2">';
        const predictionsForPattern = predictions.filter(p => p.patternType === key);
        if (predictionsForPattern.length > 0) {
             predictionsForPattern.forEach(p => {
                const resultClass = p.predicted === p.actual ? 'win' : 'loss';
                chartHtml += `<div class="bar ${resultClass}" title="D·ª± ƒëo√°n: ${p.predicted}, Th·ª±c t·∫ø: ${p.actual}"></div>`;
            });
        } else {
            chartHtml += '<div class="w-full text-center text-xs text-gray-600">Ch∆∞a c√≥ d·ªØ li·ªáu</div>';
        }
        chartHtml += '</div>';

        html += `
            <div class="bg-gray-700/50 p-3 rounded-lg relative ${highlightClass}">
                ${badgeHtml}
                <div class="grid grid-cols-3 items-center gap-2">
                    <span class="font-semibold text-sm col-span-3 sm:col-span-1">M·∫´u (${key.replace('-',':')})</span>
                    <div class="text-center">
                        <span class="text-xs text-gray-400">T·ª∑ L·ªá</span>
                        <p class="font-bold ${rate >= 50 ? 'text-green-400' : 'text-red-400'}">${rate.toFixed(1)}%</p>
                    </div>
                     <div class="text-center">
                        <span class="text-xs text-gray-400">Th·∫Øng/T·ªïng</span>
                        <p class="font-semibold text-white">${wins} / ${total}</p>
                    </div>
                </div>
                ${chartHtml}
            </div>
        `;
    }
    container.innerHTML = html;
}


function updateAllUI() {
    updateSessionListUI();
    const session = state.sessions[state.currentSessionId];
    if (session) {
        updateAnalysisUI(); 
        updateBigRoadUI();
        updateAccuracyUI();
        updateGlobalAccuracyUI();
        updatePatternStatsUI();
    }
}

// --- EVENT HANDLERS & ACTIONS ---
function addResult(result) {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    
    const analysisResult = state.analyzer.getPrediction(session.history, session.patternStats);

    if (analysisResult.prediction) {
        session.predictions.push({
            predicted: analysisResult.prediction,
            actual: result,
            logicType: analysisResult.logicType,
            patternType: analysisResult.patternType 
        });

        if (analysisResult.patternType) {
            const { patternType } = analysisResult;
            if (!session.patternStats[patternType]) {
                session.patternStats[patternType] = { wins: 0, total: 0 };
            }
            const stats = session.patternStats[patternType];
            stats.total++;
            if (analysisResult.prediction === result) {
                stats.wins++;
            }
        }
    }

    session.history.push(result);
    saveState();
    updateAllUI();
}

function undoLast() {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    if (session.history.length === 0) return;

    const lastResult = session.history[session.history.length - 1];
    const lastPredictionRecord = session.predictions.pop();
    
    if (lastPredictionRecord) {
        const { patternType, predicted } = lastPredictionRecord;
        if (patternType && session.patternStats[patternType]) {
            const stats = session.patternStats[patternType];
            stats.total--;
            if (predicted === lastResult) {
                stats.wins--;
            }
            if (stats.total <= 0) {
                delete session.patternStats[patternType];
            }
        }
    }
    
    session.history.pop();
    saveState();
    updateAllUI();
}


function clearCurrentSessionHistory() {
    if (!state.currentSessionId) return;
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?')) {
        const session = state.sessions[state.currentSessionId];
        session.history = [];
        session.predictions = [];
        session.patternStats = {};
        saveState();
        updateAllUI();
    }
}

// --- SESSION MANAGEMENT ---
function saveState() {
    localStorage.setItem('baccaratAsymmetrySessions_v4', JSON.stringify(state.sessions));
    localStorage.setItem('baccaratAsymmetryLastSession_v4', state.currentSessionId);
}

function loadState() {
    const sessions = localStorage.getItem('baccaratAsymmetrySessions_v4');
    const lastSessionId = localStorage.getItem('baccaratAsymmetryLastSession_v4');
    state.sessions = sessions ? JSON.parse(sessions) : {};
    
    Object.values(state.sessions).forEach(session => {
        if (!session.predictions) session.predictions = [];
        if (!session.patternStats) session.patternStats = {};
    });

    return lastSessionId;
}

function updateSessionListUI() {
    const container = document.getElementById('sessionListContainer');
    container.innerHTML = '';
    const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));

    if (sortedKeys.length === 0) {
        container.innerHTML = '<p class="text-center text-gray-500 p-4">Kh√¥ng c√≥ phi√™n n√†o.</p>';
        return;
    }

    sortedKeys.forEach((sessionId) => {
        const session = state.sessions[sessionId];
        const isActive = sessionId === state.currentSessionId;
        const itemDiv = document.createElement('div');
        itemDiv.className = `session-item flex items-center justify-between p-2 rounded-md hover:bg-gray-700 cursor-pointer ${isActive ? 'active' : 'bg-gray-800'}`;
        itemDiv.dataset.sessionId = sessionId;
        itemDiv.onclick = () => loadSession(sessionId);

        itemDiv.innerHTML = `
            <div class="flex flex-col">
                <span class="font-semibold text-sm">${session.name}</span>
                <span class="text-xs text-gray-400">${session.history.length} v√°n</span>
            </div>
            ${isActive ? `<span class="text-xs font-bold bg-gray-900/50 px-2 py-1 rounded-full">ƒêang ch·ªçn</span>` : ''}
        `;
        container.appendChild(itemDiv);
    });
}

function renameSession() {
    if (!state.currentSessionId) return;
    const currentName = state.sessions[state.currentSessionId].name;
    const newName = prompt("Nh·∫≠p t√™n m·ªõi cho phi√™n ƒëang ho·∫°t ƒë·ªông:", currentName);
    if (newName && newName.trim() !== "") {
        state.sessions[state.currentSessionId].name = newName.trim();
        saveState();
        updateSessionListUI();
    }
}

function deleteCurrentSession() {
    if (!state.currentSessionId) return;
    const sessionCount = Object.keys(state.sessions).length;
    if (sessionCount <= 1) {
        alert("Kh√¥ng th·ªÉ x√≥a phi√™n cu·ªëi c√πng.");
        return;
    }
    if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a phi√™n "${state.sessions[state.currentSessionId].name}" kh√¥ng?`)) {
        delete state.sessions[state.currentSessionId];
        state.currentSessionId = null;
        saveState();
        initializeApp(); 
    }
}

function createNewSession() {
    const newId = `session-${Date.now()}`;
    state.sessions[newId] = {
        name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`,
        history: [],
        predictions: [],
        patternStats: {}
    };
    state.currentSessionId = newId;
    saveState();
    updateAllUI();
}

function loadSession(sessionId) {
    if (state.sessions[sessionId]) {
        state.currentSessionId = sessionId;
        localStorage.setItem('baccaratAsymmetryLastSession_v4', state.currentSessionId);
        updateAllUI();
    }
}

// --- IMPORT / EXPORT ---
function exportData() {
    if (Object.keys(state.sessions).length === 0) {
        alert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.");
        return;
    }
    const dataStr = JSON.stringify(state.sessions, null, 2);
    const dataBlob = new Blob([dataStr], {type: "application/json"});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.download = `baccarat_asymmetry_backup_v4_${new Date().toISOString().slice(0,10)}.json`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
}

function importData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedSessions = JSON.parse(e.target.result);
            if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("Invalid format");
            
            for(const key in importedSessions) {
                const session = importedSessions[key];
                if(!session.name || !Array.isArray(session.history)) {
                    throw new Error("Invalid session data");
                }
                if (!session.predictions) session.predictions = [];
                if (!session.patternStats) session.patternStats = {}; // Handle old imports
            }

            if (confirm('D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√®. B·∫°n c√≥ ch·∫Øc mu·ªën ti·∫øp t·ª•c?')) {
                state.sessions = importedSessions;
                state.currentSessionId = null;
                localStorage.removeItem('baccaratAsymmetryLastSession_v4');
                saveState();
                initializeApp();
                alert('Nh·∫≠p d·ªØ li·ªáu th√†nh c√¥ng!');
            }
        } catch (error) {
            alert('L·ªói: File d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i file.');
            console.error("Import error:", error);
        } finally {
            event.target.value = ''; 
        }
    };
    reader.readAsText(file);
}

// --- INITIALIZATION ---
function initializeApp() {
    const lastActiveId = loadState();

    if (Object.keys(state.sessions).length === 0) {
        createNewSession();
    } else {
        const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));
        const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[0];
        loadSession(idToLoad);
    }
}

document.addEventListener('DOMContentLoaded', initializeApp);
</script>
</body>
</html>

