<!DOCTYPE html> 
 <html lang="vi"> 
 <head> 
     <meta charset="UTF-8"> 
     <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
     <title>H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (Th·ªëng K√™ N√¢ng Cao)</title> 
     <script src="https://cdn.tailwindcss.com"></script> 
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet"> 
     <style> 
         body { 
             font-family: 'Inter', sans-serif; 
             background-color: #111827; /* Tailwind gray-900 */ 
             color: #F9FAFB; /* Tailwind gray-50 */ 
         } 
         .btn { 
             transition: all 0.3s ease; 
             box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); 
         } 
         .btn:hover { 
             transform: translateY(-2px); 
             box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
         } 
         .btn:active { 
             transform: translateY(1px); 
         } 
         .card-glow-p { 
             box-shadow: 0 0 20px rgba(59, 130, 246, 0.5); 
         } 
         .card-glow-b { 
             box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); 
         } 
         .card-glow-certain { 
             box-shadow: 0 0 25px rgba(250, 204, 21, 0.7); 
         } 
         .card-glow-reliable {
            box-shadow: 0 0 25px rgba(52, 211, 153, 0.6);
         }
         /* Big Road Styles */ 
         #bigRoadDisplay { 
             display: grid; 
             grid-auto-flow: column; 
             grid-auto-columns: 2.5rem; /* 40px */ 
             gap: 2px; 
             overflow-x: auto; 
             padding: 8px; 
         } 
         .road-col { 
             display: grid; 
             grid-auto-rows: 2.5rem; /* 40px */ 
             gap: 2px; 
         } 
         .road-item { 
             width: 2.5rem; /* 40px */ 
             height: 2.5rem; /* 40px */ 
             border-radius: 9999px; 
             display: flex; 
             align-items: center; 
             justify-content: center; 
             font-weight: bold; 
             font-size: 1.125rem; /* 18px */ 
             color: white; 
             animation: fadeIn 0.5s ease; 
         } 
         @keyframes fadeIn { 
             from { opacity: 0; transform: scale(0.8); } 
             to { opacity: 1; transform: scale(1); } 
         }
         /* NEW ANIMATION FOR LAST PREDICTION HIGHLIGHT */
         @keyframes last-prediction-glow {
            0%, 100% { box-shadow: 0 0 15px rgba(250, 204, 21, 0.4); border-color: rgba(250, 204, 21, 0.7); }
            50% { box-shadow: 0 0 15px rgba(250, 204, 21, 0.8); border-color: rgba(250, 204, 21, 1); }
         }
         .last-prediction-highlight {
             animation: last-prediction-glow 2s infinite ease-in-out;
             border: 2px solid #FBBF24; /* amber-400 */
         }
     </style> 
 </head> 
 <body class="p-4 md:p-8"> 

     <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6"> 

         <!-- Left Column: Input & History --> 
         <div class="lg:col-span-2 space-y-6"> 
             <!-- Header --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center"> 
                 <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">H·ªá Th·ªëng Ph√¢n T√≠ch H√¨nh C·∫ßu</h1> 
                 <p class="text-gray-400 mt-2">Ghi nh·ªõ - ƒê·ªëi chi·∫øu - Ph√°n ƒëo√°n</p> 
             </div> 

             <!-- Session Management --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg"> 
                 <h2 class="text-xl font-semibold mb-4 text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2> 
                 
                 <!-- Normal Mode UI -->
                 <div id="normal-mode-ui">
                    <div class="flex flex-col sm:flex-row gap-4 mb-4"> 
                        <select id="sessionSelector" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"></select> 
                        <div class="grid grid-cols-2 sm:grid-cols-4 gap-4"> 
                            <button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">‚ûï M·ªõi</button> 
                            <button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">‚úèÔ∏è ƒê·ªïi T√™n</button> 
                            <button onclick="deleteSelectedSession()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a</button> 
                            <button onclick="toggleSelectionMode()" class="btn w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg">üìã Ch·ªçn...</button>
                        </div> 
                    </div> 
                 </div>

                 <!-- Selection Mode UI (hidden by default) -->
                 <div id="selection-mode-ui" class="hidden">
                    <p class="text-gray-300 mb-3 font-semibold">Ch·ªçn c√°c phi√™n b·∫°n mu·ªën x√≥a (gi·ªØ Shift ƒë·ªÉ ch·ªçn nhi·ªÅu):</p>
                    <div class="space-y-2 max-h-48 overflow-y-auto bg-gray-900/50 p-3 rounded-lg mb-4 border border-gray-700">
                        <!-- "Select All" Checkbox -->
                        <label class="flex items-center space-x-3 bg-gray-800 p-3 rounded-md hover:bg-gray-700 cursor-pointer transition-colors sticky top-0">
                            <input type="checkbox" id="select-all-checkbox" onclick="toggleSelectAll(this)" class="h-5 w-5 bg-gray-800 border-gray-600 rounded text-indigo-500 focus:ring-indigo-500 focus:ring-offset-gray-800">
                            <span class="text-white font-bold">Ch·ªçn T·∫•t C·∫£</span>
                        </label>
                        <!-- Checkboxes will be generated here -->
                        <div id="session-checkbox-list" class="space-y-2 pt-2"></div>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <button onclick="deleteMultipleSessions()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a ƒê√£ Ch·ªçn</button>
                        <button onclick="toggleSelectionMode()" class="btn w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">H·ªßy</button>
                    </div>
                 </div>


                 <!-- Import/Export --> 
                 <div class="flex flex-col sm:flex-row gap-4"> 
                     <button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t D·ªØ Li·ªáu</button> 
                     <button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p D·ªØ Li·ªáu</button> 
                     <input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)"> 
                 </div> 

                 <!-- Toggle Button for Reliable Sessions -->
                 <div class="mt-4">
                     <button onclick="toggleReliableSessions()" id="toggleReliableBtn" class="btn w-full bg-amber-600 hover:bg-amber-500 text-white font-bold py-3 px-4 rounded-lg">üîç Hi·ªán C√°c "B√†n X·ªãn"</button>
                 </div>

                 <!-- Delete All Sessions -->
                 <div class="mt-4 border-t border-red-500/30 pt-4">
                    <button onclick="deleteAllSessions()" class="btn w-full bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg">üî• X√ìA T·∫§T C·∫¢ C√ÅC PHI√äN</button>
                </div>

                 <!-- Reliable Session Analysis (MOVED HERE & HIDDEN) -->
                 <div id="reliable-sessions-container" class="bg-gray-900/50 mt-6 p-4 rounded-xl shadow-inner border-2 border-transparent transition-all duration-500 hidden">
                     <h2 class="text-lg font-semibold mb-3 text-amber-300">üí° C√°c "B√†n X·ªãn" ƒê√£ T√¨m Th·∫•y</h2>
                     <div id="reliableSessionsResult" class="space-y-3">
                         <p class="text-gray-400 text-center py-2">ƒêang ph√¢n t√≠ch c√°c phi√™n...</p>
                     </div>
                 </div>
             </div> 

             <!-- Input Section --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg"> 
                 <h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£ V√°n Hi·ªán T·∫°i</h2> 
                 <div class="grid grid-cols-2 gap-4 mb-4"> 
                     <button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl"> 
                         <span>üë§</span> PLAYER 
                     </button> 
                     <button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl"> 
                         <span>üè¶</span> BANKER 
                     </button> 
                 </div> 
                 <div class="flex gap-4"> 
                      <button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">‚Ü©Ô∏è Ho√†n T√°c</button> 
                      <button onclick="clearCurrentSessionHistory()" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a L·ªãch S·ª≠</button> 
                 </div> 
             </div> 
              
             <!-- Confidence Stats Table --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg"> 
                 <h2 class="text-xl font-semibold mb-2 text-green-300">üìä Th·ªëng K√™ ƒê·ªô Tin C·∫≠y (Phi√™n Hi·ªán T·∫°i)</h2> 
                 <!-- NEW TABS -->
                 <div class="flex justify-center my-4 border border-gray-700 rounded-lg p-1 bg-gray-900/50">
                    <button id="stats-tab-dynamic" onclick="switchStatsTab('dynamic')" class="stats-tab-btn flex-1 py-2 px-4 text-sm font-bold rounded-md transition-colors bg-cyan-600 text-white">Lu√¥n T√¨m T·ªët Nh·∫•t</button>
                    <button id="stats-tab-conservative" onclick="switchStatsTab('conservative')" class="stats-tab-btn flex-1 py-2 px-4 text-sm font-bold rounded-md transition-colors text-gray-400">B·∫£o To√†n Khi Th·∫Øng</button>
                 </div>
                 <div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center"></div> 
                 <div class="space-y-2" id="confidenceStatsTable"> 
                     <!-- Rows will be generated by JS --> 
                 </div> 
             </div> 

             <!-- History Display --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg"> 
                 <div class="flex justify-between items-center mb-4"> 
                     <h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2> 
                     <span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span> 
                 </div> 
                 <div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700"> 
                     <div id="bigRoadDisplay"> 
                         <p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p> 
                     </div> 
                 </div> 
             </div> 
         </div> 

         <!-- Right Column: Analysis & Stats --> 
         <div class="space-y-6"> 
              <!-- Accuracy Stats --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg"> 
                 <h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ (Phi√™n Hi·ªán T·∫°i)</h2> 
                 <div class="space-y-4"> 
                     <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg"> 
                         <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span> 
                         <span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span> 
                     </div> 
                     <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg"> 
                         <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span> 
                         <div> 
                             <span id="correctPredictions" class="text-lg font-semibold text-white">0</span> 
                             <span class="text-gray-400">/</span> 
                             <span id="totalPredictions" class="text-lg font-semibold text-white">0</span> 
                         </div> 
                     </div> 
                 </div> 
             </div> 
             
             <!-- Global Accuracy Stats --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg"> 
                 <h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2> 
                 <div class="space-y-4"> 
                     <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg"> 
                         <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span> 
                         <span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span> 
                     </div> 
                     <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg"> 
                         <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span> 
                         <div> 
                             <span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span> 
                             <span class="text-gray-400">/</span> 
                             <span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span> 
                         </div> 
                     </div> 
                 </div> 
             </div> 

             <!-- Pattern Analysis --> 
             <div id="analysis-card" class="bg-gray-800 p-4 rounded-2xl shadow-lg transition-all duration-500">
                 <div id="currentSessionStatus" class="mb-4 text-center p-3 rounded-lg font-bold text-lg transition-all duration-300"></div>
                 <h2 class="text-xl font-semibold mb-4 text-yellow-300 text-center">üß† Ph√¢n T√≠ch & ƒê·ªÅ Xu·∫•t Song Song</h2> 
                 <div id="analysisResult" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Dynamic Analysis Column -->
                    <div id="dynamic-analysis-container" class="bg-gray-900/50 p-4 rounded-lg border-2 border-cyan-500/50 flex flex-col">
                        <h3 class="text-lg font-bold text-center text-cyan-300 mb-3">Lu√¥n t√¨m t·ªët nh·∫•t</h3>
                        <div id="dynamic-analysis-content" class="flex-grow flex flex-col justify-center">
                            <p class="text-gray-500 text-center py-8">ƒêang t√≠nh...</p>
                        </div>
                    </div>
                    <!-- Conservative Analysis Column -->
                    <div id="conservative-analysis-container" class="bg-gray-900/50 p-4 rounded-lg border-2 border-amber-500/50 flex flex-col">
                        <h3 class="text-lg font-bold text-center text-amber-300 mb-3">B·∫£o to√†n khi th·∫Øng</h3>
                        <div id="conservative-analysis-content" class="flex-grow flex flex-col justify-center">
                            <p class="text-gray-500 text-center py-8">ƒêang t√≠nh...</p>
                        </div>
                    </div>
                 </div> 
             </div> 
              
             <!-- Analysis Settings --> 
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg"> 
                 <h2 class="text-xl font-semibold mb-4 text-purple-300">‚öôÔ∏è C√†i ƒê·∫∑t Th·ªëng K√™</h2> 
                 <div class="space-y-4"> 
                      <div>
                         <label for="optimalLengthMode" class="block text-sm font-medium text-gray-300 mb-1">Ch·∫ø ƒë·ªô ghi nh·∫≠n Th·ªëng K√™ & T·ª∑ L·ªá Th·∫Øng</label>
                         <select id="optimalLengthMode" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none">
                             <option value="dynamic">Lu√¥n t√¨m chi·ªÅu d√†i t·ªët nh·∫•t</option>
                             <option value="conservative">Ch·ªâ ƒë·ªïi chi·ªÅu d√†i khi thua</option>
                         </select>
                         <p class="text-xs text-gray-500 mt-1">L·ª±a ch·ªçn n√†y quy·∫øt ƒë·ªãnh c√°ch h·ªá th·ªëng t√≠nh to√°n T·ª∑ L·ªá Th·∫Øng v√† c√°c b·∫£ng th·ªëng k√™. B·∫£ng "Ph√¢n T√≠ch Song Song" ·ªü tr√™n s·∫Ω lu√¥n hi·ªÉn th·ªã d·ª± ƒëo√°n cho c·∫£ hai ch·∫ø ƒë·ªô.</p>
                     </div>
                 </div> 
                 <button onclick="saveSettings()" class="btn w-full mt-6 bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">L∆∞u & T√≠nh To√°n L·∫°i (N·∫øu ƒê·ªïi)</button> 
             </div> 

         </div> 
     </div> 
 
     <!-- Progress Overlay -->
     <div id="progress-overlay" class="hidden fixed inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center z-50 transition-opacity duration-300">
        <div class="text-white text-xl mb-4 font-semibold">ƒêang t√≠nh to√°n l·∫°i d·ªØ li·ªáu...</div>
        <div class="w-11/12 max-w-lg bg-gray-600 rounded-full h-6 shadow-lg">
            <div id="progress-bar" class="bg-blue-600 h-6 rounded-full text-center text-white font-bold transition-all duration-300" style="width: 0%;">0%</div>
        </div>
    </div>

     <script> 
         // --- CORE LOGIC: PATTERN MATCHER --- 
         class PatternMatcher { 
             constructor() { 
                 this.MIN_HISTORY_FOR_ANALYSIS = 10; 
                 this.MIN_PATTERN_LENGTH = 10; 
                 this.MAX_PATTERN_LENGTH = 15; 
                 this.MIN_CERTAIN_OCCURRENCES = 2; // Default value 
             } 

             calculateSimilarity(arr1, arr2) { 
                 if (arr1.length !== arr2.length || arr1.length === 0) return 0; 
                 const matches = arr1.filter((item, index) => item === arr2[index]).length; 
                 return matches / arr1.length; 
             } 

             findPatternOccurrences(pattern, allHistory) { 
                 const occurrences = []; 
                 const reversedPattern = [...pattern].reverse(); 

                 for (const session of allHistory) { 
                     const sessionHistory = session.history || []; 
                     if (sessionHistory.length < pattern.length + 1) continue; 
                      
                     for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) { 
                         const segment = sessionHistory.slice(i, i + pattern.length); 
                         const nextResult = sessionHistory[i + pattern.length]; 
                         const similarity = this.calculateSimilarity(pattern, segment); 
                          
                         if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity }); 
                          
                         const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment); 
                         if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity }); 
                     } 
                 } 
                 return occurrences; 
             } 

             getPredictionForPattern(pattern, allHistoricalSessions) { 
                  const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions); 
          
                 if (occurrences.length === 0) { 
                     return { prediction: null }; 
                 } 

                 const votes = { P: 0, B: 0 }; 
                 occurrences.forEach(match => { 
                     if (votes[match.next] !== undefined) votes[match.next] += match.similarity; 
                 }); 

                 const totalVotes = votes.P + votes.B; 
                 if (totalVotes === 0) { 
                     return { prediction: null }; 
                 } 
                  
                 const predictedWinner = votes.P > votes.B ? 'P' : 'B'; 
                 const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100; 
                  
                 return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length }; 
             } 
              
             findCertainPrediction(currentHistory, allHistoricalSessions) { 
                 for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) { 
                     const pattern = currentHistory.slice(-len); 
                     const patternString = pattern.join(''); 
                     const occurrences = []; 

                     for (const session of allHistoricalSessions) { 
                         const sessionHistory = session.history || []; 
                         if (sessionHistory.length < pattern.length + 1) continue; 
                          
                         for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) { 
                             const segment = sessionHistory.slice(i, i + pattern.length); 
                             if (segment.join('') === patternString) { 
                                 const nextResult = sessionHistory[i + pattern.length]; 
                                 occurrences.push(nextResult); 
                             } 
                         } 
                     } 

                     if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) { 
                         const predictedWinner = occurrences[0]; 
                         return { 
                             prediction: predictedWinner, 
                             recommendation: 'TAY CH·∫ÆC CH·∫ÆN', 
                             analysisText: `T√¨m th·∫•y ${occurrences.length} l·∫ßn xu·∫•t hi·ªán ch√≠nh x√°c c·ªßa h√¨nh c·∫ßu n√†y trong l·ªãch s·ª≠.\nT·∫•t c·∫£ ƒë·ªÅu cho k·∫øt qu·∫£ ti·∫øp theo l√†: ${predictedWinner}`, 
                             confidence: 100, 
                             isCertain: true 
                         }; 
                     } 
                 } 
                 return null; 
             } 


             analyzeCurrentStreak(currentHistory) { 
                 if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length }; 
                 const last = currentHistory[currentHistory.length - 1]; 
                 const secondLast = currentHistory[currentHistory.length - 2]; 
                 if (last === secondLast) { 
                     let length = 0; 
                     for (let i = currentHistory.length - 1; i >= 0; i--) { 
                         if (currentHistory[i] === last) length++; else break; 
                     } 
                     return { type: 'b·ªát', length, value: last }; 
                 } else { 
                     let length = 0; 
                     for (let i = currentHistory.length - 1; i >= 1; i--) { 
                         if (currentHistory[i] !== currentHistory[i-1]) length++; else break; 
                     } 
                     return { type: '1-1', length: length + 1 }; 
                 } 
             } 

             getPrediction(currentHistory, allHistoricalSessions, { optimalLength = null, lengthPerformance = {} } = {}) { 
                 if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) { 
                     return { prediction: null, analysisText: `C·∫ßn √≠t nh·∫•t ${this.MIN_HISTORY_FOR_ANALYSIS} k·∫øt qu·∫£...`, confidence: 0, isCertain: false }; 
                 } 
                  
                 if (optimalLength && currentHistory.length >= optimalLength) { 
                     const pattern = currentHistory.slice(-optimalLength); 
                     const result = this.getPredictionForPattern(pattern, allHistoricalSessions); 
                     if (result.prediction) { 
                         const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 }; 
                         const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A'; 
                         const analysisText = `S·ª≠ d·ª•ng chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u: ${optimalLength} v√°n.\n(T·ª∑ l·ªá th·∫Øng c·ªßa chi·ªÅu d√†i n√†y: ${rate}% - ${perf.wins}/${perf.total})\n\nL·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${result.votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${result.votes.B.toFixed(1)} ƒëi·ªÉm`; 
                         return {  
                             prediction: result.prediction,  
                             recommendation: 'THEO CHI·ªÄU D√ÄI T·ªêI ∆ØU', 
                             analysisText,  
                             confidence: result.confidence, 
                             isCertain: false 
                         }; 
                     } 
                 } 
                  
                 const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions); 
                 if (certainPrediction) { 
                     return certainPrediction; 
                 } 

                 const allMatches = []; 
                 for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) { 
                     const pattern = currentHistory.slice(-len); 
                     const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions); 
                     if (occurrences.length > 0) { 
                         allMatches.push(...occurrences); 
                         break;  
                     } 
                 } 

                 if (allMatches.length === 0) { 
                     return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª± (ch·∫ø ƒë·ªô th·ªß c√¥ng).', confidence: 0, isCertain: false }; 
                 } 

                 const votes = { P: 0, B: 0 }; 
                 allMatches.forEach(match => { 
                     if (votes[match.next] !== undefined) votes[match.next] += match.similarity; 
                 }); 

                 const totalVotes = votes.P + votes.B; 
                 if (totalVotes === 0) { 
                     return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª± (ch·∫ø ƒë·ªô th·ªß c√¥ng).', confidence: 0, isCertain: false }; 
                 } 

                 const confidenceP = (votes.P / totalVotes) * 100; 
                 const confidenceB = (votes.B / totalVotes) * 100; 
                 const maxConfidence = Math.max(confidenceP, confidenceB); 
                 const predictedWinner = votes.P > votes.B ? 'P' : 'B'; 
                 const analysisTextPrefix = `T√¨m th·∫•y ${allMatches.length} h√¨nh c·∫ßu t∆∞∆°ng t·ª±. L·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${votes.B.toFixed(1)} ƒëi·ªÉm`; 
                 const streakInfo = this.analyzeCurrentStreak(currentHistory); 
                 let recommendation = ''; 
                 if (streakInfo.type === 'b·ªát' && predictedWinner === streakInfo.value) recommendation = `THEO C·∫¶U B·ªÜT (${streakInfo.value} x${streakInfo.length})`; 
                 else if (streakInfo.type === 'b·ªát' && predictedWinner !== streakInfo.value) recommendation = `B·∫∫ C·∫¶U B·ªÜT (${streakInfo.value} x${streakInfo.length})`; 
                 else if (streakInfo.type === '1-1' && predictedWinner !== currentHistory[currentHistory.length - 1]) recommendation = `THEO C·∫¶U 1-1 (D√†i ${streakInfo.length})`; 
                 else if (streakInfo.type === '1-1' && predictedWinner === currentHistory[currentHistory.length - 1]) recommendation = `B·∫∫ C·∫¶U 1-1 (D√†i ${streakInfo.length})`; 
                 else recommendation = `THEO PH√ÇN T√çCH L·ªäCH S·ª¨`; 
                  
                 const analysisText = `${analysisTextPrefix}\n\nüèÜ ƒê·ªô tin c·∫≠y: ${maxConfidence.toFixed(1)}%`; 
                 return { prediction: predictedWinner, recommendation, analysisText, confidence: maxConfidence, isCertain: false }; 
             } 
         } 

         // --- GLOBAL STATE --- 
         let state = { 
             currentSessionId: null, 
             sessions: {}, 
             matcher: new PatternMatcher(), 
             currentPrediction: null, 
             goldenRange: {}, // Now an object: { dynamic: null, conservative: null }
             selectionModeActive: false,
             activeStatsTab: 'dynamic',
             settings: {
                optimalLengthMode: 'dynamic' // 'dynamic' or 'conservative'
             }
         }; 
         let lastCheckedCheckbox = null; // For shift-click selection
          
         // --- STATS CALCULATION --- 
         function getPredictionStats(predictions) { 
             const total = predictions.length; 
             if (total === 0) return { rate: 0, correct: 0, total: 0 }; 
             const correct = predictions.filter(p => p.predicted === p.actual).length; 
             return { rate: (correct / total) * 100, correct, total }; 
         } 

         function getConfidenceRangeString(confidence) {
             if (confidence < 50) return "D∆∞·ªõi 50%";
             if (confidence >= 50 && confidence < 60) return "50-60%";
             if (confidence >= 60 && confidence < 70) return "60-70%";
             if (confidence >= 70 && confidence < 80) return "70-80%";
             if (confidence >= 80 && confidence < 90) return "80-90%";
             if (confidence >= 90 && confidence <= 100) return "90-100%";
             return "N/A";
         }

         function calculateConfidenceStats(sessionPredictions) { 
             const ranges = [ 
                 {min: 50, max: 60}, {min: 60, max: 70},  
                 {min: 70, max: 80}, {min: 80, max: 90},  
                 {min: 90, max: 100} 
             ].map(r => ({ ...r, total: 0, wins: 0, rate: -1, trendIndicator: '', streakType: 'none', streakLength: 0 })); 
  
             if (!sessionPredictions || sessionPredictions.length === 0) { 
                 return ranges; 
             } 
  
             ranges.forEach(range => { 
                 const predictionsForRange = sessionPredictions.filter(p => { 
                     const confidence = p.confidence; 
                     return confidence >= range.min && (confidence < range.max || (range.max === 100 && confidence >= 100)); 
                 }); 
                  
                 range.total = predictionsForRange.length; 
                 range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length; 
                 range.rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1; 
  
                 let trendIndicator = ''; 
                 let streak = 0; 
                 if (predictionsForRange.length >= 1) { 
                     const lastResultIsWin = (predictionsForRange[predictionsForRange.length - 1].predicted === predictionsForRange[predictionsForRange.length - 1].actual); 
                      
                     for (let i = predictionsForRange.length - 1; i >= 0; i--) { 
                         const currentResultIsWin = (predictionsForRange[i].predicted === predictionsForRange[i].actual); 
                         if (currentResultIsWin === lastResultIsWin) { 
                             streak++; 
                         } else { 
                             break; 
                         } 
                     } 
  
                     if (streak >= 1) { 
                         if (lastResultIsWin) { 
                             range.streakType = 'win'; 
                             trendIndicator = `<span class="flex items-center text-green-400 ml-1.5">  
                                 <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>  
                                 <span class="font-bold text-xs">${streak}</span>  
                                 </span>`; 
                         } else { 
                             range.streakType = 'loss'; 
                             trendIndicator = `<span class="flex items-center text-red-400 ml-1.5">  
                                 <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>  
                                 <span class="font-bold text-xs">${streak}</span>  
                                 </span>`; 
                         } 
                         range.streakLength = streak; 
                     } 
                 } 
                 range.trendIndicator = trendIndicator; 
             }); 
              
             return ranges; 
         } 


         // --- UI UPDATE FUNCTIONS --- 
         function updateBigRoadUI() { 
             const history = state.sessions[state.currentSessionId]?.history || []; 
             const roadDiv = document.getElementById('bigRoadDisplay'); 
             document.getElementById('totalGames').textContent = history.length; 

             if (history.length === 0) { 
                 roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>'; 
                 roadDiv.style.display = 'block'; 
                 return; 
             } 
             roadDiv.style.display = 'grid'; 
             roadDiv.innerHTML = ''; 

             const columns = []; 
             if (history.length > 0) { 
                 let currentCol = [history[0]]; 
                 for (let i = 1; i < history.length; i++) { 
                     if (history[i] === history[i-1]) { 
                         currentCol.push(history[i]); 
                     } else { 
                         columns.push(currentCol); 
                         currentCol = [history[i]]; 
                     } 
                 } 
                 columns.push(currentCol); 
             } 

             columns.forEach(colData => { 
                 const colDiv = document.createElement('div'); 
                 colDiv.className = 'road-col'; 
                 colData.forEach(item => { 
                     const itemDiv = document.createElement('div'); 
                     const bgColor = item === 'P' ? 'bg-blue-600' : 'bg-red-600'; 
                     itemDiv.className = `road-item ${bgColor}`; 
                     itemDiv.textContent = item; 
                     colDiv.appendChild(itemDiv); 
                 }); 
                 roadDiv.appendChild(colDiv); 
             }); 
             roadDiv.scrollLeft = roadDiv.scrollWidth; 
         } 

         function updateAccuracyUI() { 
             const predictions = state.sessions[state.currentSessionId]?.predictions || []; 
             const stats = getPredictionStats(predictions); 
             const accuracyRateEl = document.getElementById('accuracyRate');
             const correctPredictionsEl = document.getElementById('correctPredictions');
             const totalPredictionsEl = document.getElementById('totalPredictions');
             if (accuracyRateEl) {
                 accuracyRateEl.textContent = `${stats.rate.toFixed(1)}%`;
             }
             if (correctPredictionsEl) {
                 correctPredictionsEl.textContent = stats.correct;
             }
             if (totalPredictionsEl) {
                 totalPredictionsEl.textContent = stats.total;
             }
         } 

         function updateGlobalAccuracyUI() { 
             const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []); 
             const stats = getPredictionStats(allPredictions); 
             const globalAccuracyRateEl = document.getElementById('globalAccuracyRate');
             const globalCorrectPredictionsEl = document.getElementById('globalCorrectPredictions');
             const globalTotalPredictionsEl = document.getElementById('globalTotalPredictions');
             if (globalAccuracyRateEl) {
                globalAccuracyRateEl.textContent = `${stats.rate.toFixed(1)}%`; 
             }
             if (globalCorrectPredictionsEl) {
                globalCorrectPredictionsEl.textContent = stats.correct; 
             }
             if (globalTotalPredictionsEl) {
                globalTotalPredictionsEl.textContent = stats.total; 
             }
         } 

         function updateAnalysisUI() {
             const session = state.sessions[state.currentSessionId];
             if (!session) return;
             
             const currentHistory = session.history;
             const allHistory = Object.values(state.sessions);

             const findBestPerformingLength = (lp) => {
                 if (!lp || Object.keys(lp).length === 0) return null;
                 const candidates = Object.entries(lp)
                     .filter(([, stats]) => stats.total > 0)
                     .map(([len, stats]) => ({
                         length: parseInt(len),
                         rate: stats.wins / stats.total,
                         total: stats.total
                     }));
                 if (candidates.length === 0) return null;
                 candidates.sort((a, b) => {
                     if (b.rate !== a.rate) return b.rate - a.rate;
                     return b.total - a.total;
                 });
                 return candidates[0].length;
             };

             const renderAnalysisColumn = (contentEl, analysis, optimalLength, mode) => {
                const { prediction, recommendation, analysisText, confidence, isCertain } = analysis;
                
                let finalPrediction = prediction;
                let finalRecommendation = recommendation;
                let recommendationNote = '';
                const activeGoldenRange = state.goldenRange[mode];

                if (prediction && !isCertain) {
                    let isInGoldenRange = false;
                    if (activeGoldenRange && confidence >= activeGoldenRange.min && confidence <= activeGoldenRange.max) {
                        isInGoldenRange = true;
                    }
                    if (isInGoldenRange) {
                        if (activeGoldenRange.rate < 30) {
                            finalPrediction = prediction === 'P' ? 'B' : 'P';
                            finalRecommendation = `ƒê·ªÄ XU·∫§T NG∆Ø·ª¢C (T·ª∑ l·ªá th·∫•p)`;
                            recommendationNote = `<div class="mt-2 p-2 text-center bg-red-800 bg-opacity-50 rounded-lg text-xs text-red-300 font-semibold">‚ö†Ô∏è ƒê·∫£o ng∆∞·ª£c! Kho·∫£ng v√†ng (${activeGoldenRange.min}-${activeGoldenRange.max}%) c√≥ t·ª∑ l·ªá th·∫Øng ch·ªâ ${activeGoldenRange.rate.toFixed(1)}%.</div>`;
                        } else {
                            recommendationNote = `<div class="mt-2 p-2 text-center bg-green-800 bg-opacity-50 rounded-lg text-xs text-green-300 font-semibold">‚ú® Ph√°n ƒëo√°n n√†y n·∫±m trong KHO·∫¢NG V√ÄNG!</div>`;
                        }
                    } else if (activeGoldenRange) {
                        recommendationNote = `<div class="mt-2 p-2 text-center bg-yellow-800 bg-opacity-50 rounded-lg text-xs text-yellow-300 font-semibold">‚ö†Ô∏è C·∫©n tr·ªçng: Kh√¥ng thu·ªôc Kho·∫£ng V√†ng.</div>`;
                    }
                }

                let optimalLengthDisplay = optimalLength ? `<div class="mb-3 p-2 bg-gray-800 rounded-lg text-center text-cyan-300 text-xs"> 
                     <span class="font-semibold">ƒê·ªô d√†i c·∫ßu:</span> 
                     <span class="font-bold ml-1">${optimalLength}</span> 
                 </div>` : '';

                if (finalPrediction) {
                    let predictionBlockHTML = '';
                    if (isCertain) {
                        predictionBlockHTML = `<div class="text-center bg-yellow-800 bg-opacity-50 py-4 rounded-lg border-2 border-yellow-400"> 
                            <p class="text-sm text-yellow-300 mb-1 animate-pulse">Ch·∫Øc Ch·∫Øn (L·ªãch s·ª≠):</p> 
                            <p class="text-xl font-extrabold text-yellow-300">${finalRecommendation}</p> 
                            <p class="text-3xl font-bold mt-1">${finalPrediction === 'P' ? 'üë§ P' : 'üè¶ B'}</p> 
                            <p class="text-xs text-yellow-200 mt-2">ƒê·ªô tin c·∫≠y: <span class="font-bold text-white">100%</span></p></div>`;
                    } else {
                        const confidenceRangeStr = getConfidenceRangeString(confidence);
                        predictionBlockHTML = `<div class="text-center bg-gray-900 py-4 rounded-lg border-2 ${finalPrediction === 'P' ? 'border-blue-500' : 'border-red-500'}"> 
                            <p class="text-sm text-gray-400 mb-1">ƒê·ªÅ xu·∫•t:</p> 
                            <p class="text-xl font-extrabold ${finalPrediction === 'P' ? 'text-blue-400' : 'text-red-400'}">${finalRecommendation}</p> 
                            <p class="text-3xl font-bold mt-1">${finalPrediction === 'P' ? 'üë§ P' : 'üè¶ B'}</p> 
                            <p class="text-xs text-gray-400 mt-2">ƒê·ªô tin c·∫≠y: <span class="font-bold text-white">${confidence.toFixed(1)}%</span> (${confidenceRangeStr})</p> 
                            ${recommendationNote}</div>`;
                    }
                    contentEl.innerHTML = `${optimalLengthDisplay}${predictionBlockHTML}`;
                } else {
                    contentEl.innerHTML = `${optimalLengthDisplay}<p class="text-gray-400 text-center py-8 whitespace-pre-wrap text-sm">${analysisText}</p>`;
                }
             };

             // --- DYNAMIC MODE ANALYSIS ---
             const dynamicOptimalLength = findBestPerformingLength(session.lengthPerformance);
             const dynamicAnalysis = state.matcher.getPrediction(currentHistory, allHistory, {
                 optimalLength: dynamicOptimalLength,
                 lengthPerformance: session.lengthPerformance
             });
             renderAnalysisColumn(document.getElementById('dynamic-analysis-content'), dynamicAnalysis, dynamicOptimalLength, 'dynamic');

             // --- CONSERVATIVE MODE ANALYSIS ---
             const lastPrediction = session.predictions.length > 0 ? session.predictions[session.predictions.length - 1] : null;
             const wasLastPredictionCorrect = lastPrediction && lastPrediction.predicted === lastPrediction.actual;
             let conservativeOptimalLength;
             if (wasLastPredictionCorrect && session.optimalLength) {
                 conservativeOptimalLength = session.optimalLength;
             } else {
                 conservativeOptimalLength = findBestPerformingLength(session.lengthPerformance);
             }
             const conservativeAnalysis = state.matcher.getPrediction(currentHistory, allHistory, {
                 optimalLength: conservativeOptimalLength,
                 lengthPerformance: session.lengthPerformance
             });
             renderAnalysisColumn(document.getElementById('conservative-analysis-content'), conservativeAnalysis, conservativeOptimalLength, 'conservative');
             
             // --- STORE OFFICIAL PREDICTION FOR STATS ---
             if (state.settings.optimalLengthMode === 'dynamic') {
                 state.currentPrediction = { prediction: dynamicAnalysis.prediction, confidence: dynamicAnalysis.confidence };
             } else {
                 state.currentPrediction = { prediction: conservativeAnalysis.prediction, confidence: conservativeAnalysis.confidence };
             }
         }
          
         function updateConfidenceStatsUI(sessionPredictions, lastConfidence = null) { 
             const tableDiv = document.getElementById('confidenceStatsTable'); 
             const recommendationDiv = document.getElementById('confidenceRecommendation'); 
             const session = state.sessions[state.currentSessionId];
             if (!session) return;
             
             const ranges = calculateConfidenceStats(sessionPredictions); 
              
             let bestRange = null; 
             let maxRate = -1; 
 
             ranges.forEach(range => { 
                  if (range.total >= 3 && range.rate > maxRate) { 
                      maxRate = range.rate; 
                      bestRange = range; 
                  } 
             }); 
              
             state.goldenRange[state.activeStatsTab] = bestRange;  
 
             if (bestRange) { 
                 recommendationDiv.innerHTML = `<p class="text-sm text-yellow-300"><span class="font-bold">‚ú® Kho·∫£ng V√†ng (Ch·∫ø ƒë·ªô n√†y):</span> T·ª∑ l·ªá th·∫Øng cao nh·∫•t l√† <b class="text-green-400">${maxRate.toFixed(1)}%</b> trong kho·∫£ng <b class="text-white">${bestRange.min}%-${bestRange.max}%</b>.</p>`; 
             } else { 
                 recommendationDiv.innerHTML = `<p class="text-sm text-gray-400">Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√¨m ra kho·∫£ng v√†ng cho ch·∫ø ƒë·ªô n√†y (c·∫ßn t·ªëi thi·ªÉu 3 ph√°n ƒëo√°n trong 1 kho·∫£ng).</p>`; 
             } 
 
             let html = ` 
                 <div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 3fr 2fr 2fr 3fr 5fr;"> 
                     <span class="text-left">Kho·∫£ng</span> 
                     <span class="text-center">T·ªïng</span> 
                     <span class="text-center">Th·∫Øng</span> 
                     <span class="text-right">T·ª∑ L·ªá</span> 
                     <span class="text-left pl-1">Chu·ªói G·∫ßn ƒê√¢y</span>
                 </div> 
             `; 
             if (sessionPredictions.length === 0) { 
                 tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu th·ªëng k√™ cho phi√™n n√†y.</p>'; 
             } else { 
                  ranges.forEach(range => { 
                     const rate = range.rate; 
                     const isBest = range === bestRange; 
                     
                     // Highlight only if the active tab matches the official mode
                     const isLastPredictionRange = state.activeStatsTab === state.settings.optimalLengthMode && lastConfidence !== null && lastConfidence >= range.min && (lastConfidence < range.max || (range.max === 100 && lastConfidence >= 100));

                     let classList = ['grid', 'gap-x-2', 'items-center', 'p-3', 'rounded-lg', 'mt-2', 'transition-all', 'duration-300', 'text-sm'];

                     if (isLastPredictionRange) {
                        classList.push('last-prediction-highlight');
                     } else if (isBest) {
                        classList.push('bg-green-800', 'bg-opacity-40', 'border', 'border-green-500');
                     } else {
                        classList.push('bg-gray-700', 'bg-opacity-50');
                     }
                     
                     // Chart Generation Logic
                     const predictionsForRange = sessionPredictions.filter(p => {
                         const confidence = p.confidence;
                         return confidence >= range.min && (confidence < range.max || (range.max === 100 && confidence >= 100));
                     });
                     const recentPredictions = predictionsForRange.slice(-12); // Get last 12
                     let chartHTML = '';
                     if (recentPredictions.length > 0) {
                         recentPredictions.forEach(p => {
                             const isWin = p.predicted === p.actual;
                             const barColor = isWin ? 'bg-blue-500' : 'bg-red-600';
                             const barHeight = isWin ? 'h-5' : 'h-2';
                             const tooltip = `D·ª± ƒëo√°n: ${p.predicted}, Th·ª±c t·∫ø: ${p.actual}, ƒê·ªô tin c·∫≠y: ${p.confidence.toFixed(0)}%`;
                             chartHTML += `<div class="${barColor} ${barHeight} w-1.5 rounded-full" title="${tooltip}"></div>`;
                         });
                     }

                     html += ` 
                         <div class="${classList.join(' ')}" style="grid-template-columns: 3fr 2fr 2fr 3fr 5fr;"> 
                             <span class="font-medium text-gray-300 text-left">${range.min}%-${range.max}%</span> 
                             <span class="text-white font-semibold text-center">${range.total}</span> 
                             <span class="text-green-400 font-semibold text-center">${range.wins}</span> 
                             <span class="font-bold flex items-center justify-end ${rate >= 70 ? 'text-green-400' : (rate >= 50 ? 'text-yellow-400' : 'text-red-400')}"> 
                                 ${rate > -1 ? rate.toFixed(1) + '%' : '-'} 
                                 ${range.trendIndicator} 
                             </span>
                             <div class="flex items-end justify-start gap-1 h-6 pl-1">
                                 ${chartHTML || '<span class="text-xs text-gray-600">...</span>'}
                             </div>
                         </div> 
                     `; 
                 }); 
                 tableDiv.innerHTML = html; 
             } 
         } 
         
         function getSessionReliability(sessionId) {
            if (!state.sessions[sessionId]) return null;

            const session = state.sessions[sessionId];
            const predictions = session.predictions || [];
            if (predictions.length < 7) return null;

            const confidenceStats = calculateConfidenceStats(predictions);
            for (const range of confidenceStats) {
                if (range.rate > 70 && range.total >= 7 && range.streakType === 'win' && range.streakLength > 0) {
                    return { type: 'win', reason: `C√≥ d√¢y th·∫Øng ·ªü kho·∫£ng ${range.min}-${range.max}%` };
                }
                if (range.rate < 30 && range.total >= 10 && range.streakType === 'loss' && range.streakLength > 0) {
                    return { type: 'loss', reason: `C√≥ d√¢y thua ·ªü kho·∫£ng ${range.min}-${range.max}%` };
                }
            }
            return null;
         }

         // --- NEW: CURRENT SESSION STATUS UI ---
         function updateCurrentSessionStatusUI() {
             const statusDiv = document.getElementById('currentSessionStatus');
             const analysisCard = document.getElementById('analysis-card');
             const reliability = getSessionReliability(state.currentSessionId);

             analysisCard.classList.remove('card-glow-reliable');

             if (reliability) {
                 if (reliability.type === 'win') {
                    statusDiv.innerHTML = `‚úÖ PHI√äN TIN C·∫¨Y (N√äN CH∆†I)`;
                    statusDiv.className = 'mb-4 text-center p-3 rounded-lg font-bold text-lg transition-all duration-300 bg-green-600 text-green-100 border-2 border-green-400';
                    analysisCard.classList.add('card-glow-reliable');
                 } else { // 'loss'
                    statusDiv.innerHTML = `‚ö†Ô∏è PHI√äN TIN C·∫¨Y (C√ÇN NH·∫ÆC ƒê√ÅNH NG∆Ø·ª¢C)`;
                    statusDiv.className = 'mb-4 text-center p-3 rounded-lg font-bold text-lg transition-all duration-300 bg-red-600 text-red-100 border-2 border-red-400';
                    analysisCard.classList.add('card-glow-reliable');
                 }
             } else {
                 statusDiv.innerHTML = `‚Ä¶ C·∫¶N THEO D√ïI TH√äM ‚Ä¶`;
                 statusDiv.className = 'mb-4 text-center p-3 rounded-lg font-bold text-lg transition-all duration-300 bg-gray-700 text-gray-300';
             }
         }

         function findReliableSessions() { 
             const reliableSessions = []; 
             for (const sessionId in state.sessions) { 
                 const session = state.sessions[sessionId]; 
                 const reliability = getSessionReliability(sessionId);

                 if (reliability) {
                     let detailedReason = '';
                     const confidenceStats = calculateConfidenceStats(session.predictions || []);
                     for (const range of confidenceStats) {
                         if ((reliability.type === 'win' && range.rate > 70 && range.total >= 7 && range.streakType === 'win') || 
                             (reliability.type === 'loss' && range.rate < 30 && range.total >= 10 && range.streakType === 'loss')) {
                             detailedReason = `Kho·∫£ng ${range.min}-${range.max}% c√≥ t·ª∑ l·ªá <b>${range.rate.toFixed(1)}%</b> (${range.wins}/${range.total}) v√† ƒëang trong <b>chu·ªói ${range.streakLength} ${reliability.type === 'win' ? 'th·∫Øng' : 'thua'}</b>.`;
                             break;
                         }
                     }
                     reliableSessions.push({ sessionId, name: session.name, reason: detailedReason, type: reliability.type });
                 }
             } 
             return reliableSessions; 
         } 

         function updateReliableSessionsUI() { 
             const reliableSessions = findReliableSessions(); 
             const container = document.getElementById('reliableSessionsResult'); 
             const containerCard = document.getElementById('reliable-sessions-container'); 
  
             if (reliableSessions.length > 0) { 
                 containerCard.classList.remove('border-transparent'); 
                 containerCard.classList.add('border-amber-400', 'card-glow-certain');  
                  
                 let html = ''; 
                 reliableSessions.forEach(session => { 
                     const buttonColor = session.type === 'win' ? 'bg-green-600 hover:bg-green-500' : 'bg-red-600 hover:bg-red-500'; 
                     const icon = session.type === 'win' ? 'üìà' : 'üìâ'; 
  
                     html += ` 
                         <div class="bg-gray-900 p-4 rounded-lg border-l-4 ${session.type === 'win' ? 'border-green-500' : 'border-red-500'}"> 
                             <div class="flex justify-between items-center"> 
                                  <h3 class="font-bold text-lg text-white">${icon} ${session.name}</h3> 
                                  <button onclick="loadSession('${session.sessionId}')" class="btn text-xs ${buttonColor} text-white font-bold py-2 px-3 rounded-lg">Chuy·ªÉn T·ªõi</button> 
                             </div> 
                             <p class="text-sm text-gray-300 mt-2">${session.reason}</p> 
                         </div> 
                     `; 
                 }); 
                 container.innerHTML = html; 
  
             } else { 
                 containerCard.classList.add('border-transparent'); 
                 containerCard.classList.remove('border-amber-400', 'card-glow-certain'); 
                 container.innerHTML = '<p class="text-gray-400 text-center py-2">Ch∆∞a t√¨m th·∫•y "b√†n x·ªãn" n√†o.</p>'; 
             } 
         } 


         function updateAllUI() { 
             updateBigRoadUI(); 
             updateAccuracyUI(); 
             updateGlobalAccuracyUI(); 
             switchStatsTab(state.activeStatsTab); // This calls updateConfidenceStatsUI
             updateCurrentSessionStatusUI(); 
             updateAnalysisUI(); 
             updateReliableSessionsUI(); 
         } 

         // --- EVENT HANDLERS & ACTIONS --- 
         function addResult(result) { 
             if (!state.currentSessionId) return; 
             const session = state.sessions[state.currentSessionId]; 
             const historyBeforeAdd = [...session.history]; 
             const allSessions = Object.values(state.sessions); 

             // Determine if the last prediction was correct
             const wasPredictionCorrect = state.currentPrediction && state.currentPrediction.prediction === result;
             const currentOptimalLength = session.optimalLength;

             // --- NEW LOGIC FOR OPTIMAL LENGTH ---
             if (state.settings.optimalLengthMode === 'conservative' && wasPredictionCorrect && currentOptimalLength) {
                 // CONSERVATIVE MODE & CORRECT PREDICTION:
                 // The optimal length does not change. We only update its performance stats.
                 const pattern = historyBeforeAdd.slice(-currentOptimalLength);
                 const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions);
                 
                 if (prediction) {
                     if (!session.lengthPerformance[currentOptimalLength]) {
                         session.lengthPerformance[currentOptimalLength] = { wins: 0, total: 0 };
                     }
                     const stats = session.lengthPerformance[currentOptimalLength];
                     stats.total++;
                     if (prediction === result) {
                         stats.wins++;
                     }
                 }
                 // session.optimalLength remains the same.

             } else {
                 // DYNAMIC MODE (always search) OR CONSERVATIVE MODE ON A LOSS (or if no length is set yet)
                 // Run the full search for the best length.
                 const newOptimalLength = updateLengthPerformanceAndFindOptimal(historyBeforeAdd, allSessions, result, session);
                 session.optimalLength = newOptimalLength;
             }
             // --- END NEW LOGIC ---

             if (state.currentPrediction && state.currentPrediction.prediction) { 
                 session.predictions.push({  
                     predicted: state.currentPrediction.prediction,  
                     actual: result, 
                     confidence: state.currentPrediction.confidence 
                 });
                 session.lastPredictionConfidence = state.currentPrediction.confidence;
             } else {
                 session.lastPredictionConfidence = null;
             }
             state.currentPrediction = null;  

             session.history.push(result); 
              
             saveSessions(); 
             updateAllUI(); 
         } 

         function updateLengthPerformanceAndFindOptimal(history, allSessions, newResult, targetSession) { 
             const session = targetSession;
             if (!session.lengthPerformance) { 
                 session.lengthPerformance = {}; 
             } 

             const candidates = []; 

             for (let len = 10; len <= 20; len++) { 
                 if (history.length < len) continue; 

                 const pattern = history.slice(-len); 
                 const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions); 

                 if (prediction) { 
                     if (!session.lengthPerformance[len]) { 
                         session.lengthPerformance[len] = { wins: 0, total: 0 }; 
                     } 
                      
                     const stats = session.lengthPerformance[len]; 
                     stats.total++; 
                     if (prediction === newResult) { 
                         stats.wins++; 
                     } 
                      
                     if (prediction === newResult) { 
                         candidates.push({ 
                             length: len, 
                             rate: stats.wins / stats.total, 
                             total: stats.total 
                         }); 
                     } 
                 } 
             } 
              
             if (candidates.length === 0) { 
                 return session.optimalLength; 
             } 

             candidates.sort((a, b) => { 
                 if (b.rate !== a.rate) { 
                     return b.rate - a.rate; 
                 } 
                 return b.total - a.total; 
             }); 
              
             return candidates[0].length; 
         } 

         function undoLast() { 
             if (!state.currentSessionId || state.sessions[state.currentSessionId].history.length === 0) return; 
             const session = state.sessions[state.currentSessionId];
             session.history.pop(); 
              
             const predictions = session.predictions; 
             if (predictions.length > 0) { 
                 predictions.pop(); 
             } 
             
             session.lastPredictionConfidence = null;
              
             saveSessions(); 
             updateAllUI(); 
         } 

         function clearCurrentSessionHistory() { 
             if (!state.currentSessionId) return; 
             if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?')) { 
                 const session = state.sessions[state.currentSessionId]; 
                 session.history = []; 
                 session.predictions = []; 
                 session.lengthPerformance = {}; 
                 session.optimalLength = null; 
                 session.lastPredictionConfidence = null;
                 saveSessions(); 
                 updateAllUI(); 
             } 
         } 

         // --- SESSION MANAGEMENT --- 
         function getSessions() { 
             try { 
                 return JSON.parse(localStorage.getItem('baccaratPatternSessions_v4')) || {}; 
             } catch (e) { return {}; } 
         } 

         function saveSessions() { 
             localStorage.setItem('baccaratPatternSessions_v4', JSON.stringify(state.sessions)); 
             localStorage.setItem('lastActiveSession_v4', state.currentSessionId); 
         } 
          
         function renameSession() { 
             if (!state.currentSessionId) return; 
             const currentName = state.sessions[state.currentSessionId].name; 
             const newName = prompt("Nh·∫≠p t√™n m·ªõi cho phi√™n:", currentName); 
             if (newName && newName.trim() !== "") { 
                 state.sessions[state.currentSessionId].name = newName.trim(); 
                 saveSessions(); 
                 updateSessionSelector(); 
             } 
         } 

         function updateSessionSelector() { 
             if (state.selectionModeActive) {
                updateSessionSelectorCheckboxes();
             } else {
                updateSessionSelectorDropdown();
             }
         } 

         function updateSessionSelectorDropdown() {
             const selector = document.getElementById('sessionSelector'); 
             selector.innerHTML = ''; 
             const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1])); 
              
             sortedKeys.forEach((sessionId) => { 
                 const session = state.sessions[sessionId]; 
                 const option = document.createElement('option'); 
                 option.value = sessionId; 
                 option.textContent = `${session.name} (${session.history.length} v√°n)`; 
                 selector.appendChild(option); 
             }); 
             selector.value = state.currentSessionId; 
             selector.onchange = () => loadSession(selector.value); 
         }

         function updateSessionSelectorCheckboxes() {
            const listDiv = document.getElementById('session-checkbox-list');
            listDiv.innerHTML = '';
            const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1]));

            if (sortedKeys.length === 0) {
                listDiv.innerHTML = '<p class="text-gray-500">Kh√¥ng c√≥ phi√™n n√†o.</p>';
                document.getElementById('select-all-checkbox').disabled = true;
                return;
            }
            document.getElementById('select-all-checkbox').disabled = false;


            sortedKeys.forEach(sessionId => {
                const session = state.sessions[sessionId];
                const isCurrent = sessionId === state.currentSessionId;

                const label = document.createElement('label');
                label.className = 'flex items-center space-x-3 bg-gray-700 p-3 rounded-md hover:bg-gray-600 cursor-pointer transition-colors';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = sessionId;
                checkbox.className = 'h-5 w-5 bg-gray-800 border-gray-600 rounded text-indigo-500 focus:ring-indigo-500 focus:ring-offset-gray-800 session-checkbox-item';
                checkbox.name = 'session-checkbox';
                checkbox.onclick = (event) => handleCheckboxClick(event, checkbox);


                const span = document.createElement('span');
                span.textContent = `${session.name} (${session.history.length} v√°n)`;
                span.className = 'text-white';

                if (isCurrent) {
                    span.innerHTML += ' <span class="text-xs text-blue-400 font-bold">(hi·ªán t·∫°i)</span>';
                    checkbox.disabled = true;
                    label.classList.add('opacity-70', 'cursor-not-allowed');
                }

                label.appendChild(checkbox);
                label.appendChild(span);
                listDiv.appendChild(label);
            });
            updateSelectAllCheckboxState();
         }

         function createNewSession() { 
             if (state.selectionModeActive) toggleSelectionMode();
             const newId = `session-${Date.now()}`; 
             state.currentSessionId = newId; 
             state.sessions[newId] = {  
                 name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`,  
                 history: [], 
                 predictions: [],
                 predictions_dynamic: [],
                 predictions_conservative: [],
                 lengthPerformance: {}, 
                 optimalLength: null,
                 lastPredictionConfidence: null
             }; 
             saveSessions(); 
             updateSessionSelector(); 
             updateAllUI(); 
         } 

         function deleteSelectedSession() { 
             if (!state.currentSessionId || Object.keys(state.sessions).length <= 1) { 
                 alert('Kh√¥ng th·ªÉ x√≥a phi√™n cu·ªëi c√πng.'); 
                 return; 
             } 
             if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a phi√™n n√†y kh√¥ng?')) { 
                 delete state.sessions[state.currentSessionId]; 
                 state.currentSessionId = null; 
                 localStorage.removeItem('lastActiveSession_v4'); 
                 saveSessions(); 
                 initializeApp(); 
             } 
         } 

         function deleteMultipleSessions() {
            const checkboxes = document.querySelectorAll('input[name="session-checkbox"]:checked');
            const idsToDelete = Array.from(checkboxes).map(cb => cb.value);

            if (idsToDelete.length === 0) {
                alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt phi√™n ƒë·ªÉ x√≥a.');
                return;
            }

            const sessionNames = idsToDelete.map(id => state.sessions[id].name).join('\n - ');
            
            if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${idsToDelete.length} phi√™n ƒë√£ ch·ªçn kh√¥ng?\n\n - ${sessionNames}\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!`)) {
                idsToDelete.forEach(id => {
                    delete state.sessions[id];
                });
                
                saveSessions();
                toggleSelectionMode(); // Exit selection mode
                initializeApp(); // Re-initialize to refresh the state and UI
                alert(`${idsToDelete.length} phi√™n ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng.`);
            }
         }

         function deleteAllSessions() {
            if (confirm('B·∫†N C√ì CH·∫ÆC MU·ªêN X√ìA T·∫§T C·∫¢ C√ÅC PHI√äN KH√îNG?\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!')) {
                state.sessions = {};
                state.currentSessionId = null;
                localStorage.removeItem('baccaratPatternSessions_v4');
                localStorage.removeItem('lastActiveSession_v4');
                // Re-initialize the app, which will create a new default session
                initializeApp();
                alert('ƒê√£ x√≥a t·∫•t c·∫£ c√°c phi√™n.');
            }
         }

         function toggleSelectionMode() {
            state.selectionModeActive = !state.selectionModeActive;
            lastCheckedCheckbox = null; // Reset for shift-click

            const normalModeUI = document.getElementById('normal-mode-ui');
            const selectionModeUI = document.getElementById('selection-mode-ui');

            if (state.selectionModeActive) {
                normalModeUI.classList.add('hidden');
                selectionModeUI.classList.remove('hidden');
            } else {
                normalModeUI.classList.remove('hidden');
                selectionModeUI.classList.add('hidden');
            }
            updateSessionSelector();
         }

         function handleCheckboxClick(event, currentCheckbox) {
            const checkboxes = Array.from(document.querySelectorAll('.session-checkbox-item:not(:disabled)'));

            if (event.shiftKey && lastCheckedCheckbox) {
                const start = checkboxes.indexOf(lastCheckedCheckbox);
                const end = checkboxes.indexOf(currentCheckbox);
                const range = (start < end) ? checkboxes.slice(start, end + 1) : checkboxes.slice(end, start + 1);
                
                range.forEach(checkbox => checkbox.checked = lastCheckedCheckbox.checked);
            }
            
            lastCheckedCheckbox = currentCheckbox;
            updateSelectAllCheckboxState();
         }

         function toggleSelectAll(source) {
            const checkboxes = document.querySelectorAll('.session-checkbox-item:not(:disabled)');
            checkboxes.forEach(checkbox => {
                checkbox.checked = source.checked;
            });
            lastCheckedCheckbox = null;
         }

         function updateSelectAllCheckboxState() {
            const checkboxes = document.querySelectorAll('.session-checkbox-item:not(:disabled)');
            const checkedCount = document.querySelectorAll('.session-checkbox-item:checked:not(:disabled)').length;
            const selectAll = document.getElementById('select-all-checkbox');
            
            if (checkboxes.length > 0 && checkedCount === checkboxes.length) {
                selectAll.checked = true;
                selectAll.indeterminate = false;
            } else if (checkedCount > 0) {
                selectAll.checked = false;
                selectAll.indeterminate = true;
            } else {
                selectAll.checked = false;
                selectAll.indeterminate = false;
            }
         }


         function toggleReliableSessions() {
            const container = document.getElementById('reliable-sessions-container');
            const button = document.getElementById('toggleReliableBtn');
            container.classList.toggle('hidden');
            if (container.classList.contains('hidden')) {
                button.innerHTML = 'üîç Hi·ªán C√°c "B√†n X·ªãn"';
            } else {
                button.innerHTML = 'üôà ·∫®n C√°c "B√†n X·ªãn"';
            }
         }

         function switchStatsTab(mode) {
             state.activeStatsTab = mode;
             // Update button styles
             document.querySelectorAll('.stats-tab-btn').forEach(btn => {
                 btn.classList.remove('bg-cyan-600', 'text-white');
                 btn.classList.add('text-gray-400');
             });
             const activeBtn = document.getElementById(`stats-tab-${mode}`);
             activeBtn.classList.add('bg-cyan-600', 'text-white');
             activeBtn.classList.remove('text-gray-400');

             // Get predictions and update UI
             const currentSession = state.sessions[state.currentSessionId];
             if (!currentSession) return;
             
             // Regenerate predictions for the selected tab view on the fly
             const tempPredictions = getTemporaryPredictions(currentSession, mode);
             updateConfidenceStatsUI(tempPredictions, currentSession.lastPredictionConfidence);
             // Also need to refresh the main analysis view to use the correct golden range
             updateAnalysisUI();
         }

         function getTemporaryPredictions(session, mode) {
             if (!session) return [];
             
             const tempPredictions = [];
             let tempLengthPerformance = {};
             let tempOptimalLength = null;
             const allHistory = Object.values(state.sessions);

             const findBestPerformingLength = (lp) => {
                 if (!lp || Object.keys(lp).length === 0) return null;
                 const candidates = Object.entries(lp).filter(([, stats]) => stats.total > 0).map(([len, stats]) => ({
                         length: parseInt(len),
                         rate: stats.wins / stats.total,
                         total: stats.total
                 }));
                 if (candidates.length === 0) return null;
                 candidates.sort((a, b) => {
                     if (b.rate !== a.rate) return b.rate - a.rate;
                     return b.total - a.total;
                 });
                 return candidates[0].length;
             };

             for (let i = 0; i < session.history.length; i++) {
                 const historyBeforeAdd = session.history.slice(0, i);
                 const result = session.history[i];

                 if (historyBeforeAdd.length < state.matcher.MIN_HISTORY_FOR_ANALYSIS) {
                     continue;
                 }

                 const { prediction, confidence } = state.matcher.getPrediction(historyBeforeAdd, allHistory, {
                     optimalLength: tempOptimalLength,
                     lengthPerformance: tempLengthPerformance
                 });

                 if (prediction) {
                     tempPredictions.push({
                         predicted: prediction,
                         actual: result,
                         confidence: confidence
                     });
                 }

                 const wasPredictionCorrect = prediction === result;

                 // Update next optimal length based on the requested mode for this simulation
                 if (mode === 'conservative' && wasPredictionCorrect && tempOptimalLength) {
                     const pattern = historyBeforeAdd.slice(-tempOptimalLength);
                     const { prediction: lenPrediction } = state.matcher.getPredictionForPattern(pattern, allHistory);
                     if (lenPrediction) {
                         if (!tempLengthPerformance[tempOptimalLength]) tempLengthPerformance[tempOptimalLength] = { wins: 0, total: 0 };
                         const stats = tempLengthPerformance[tempOptimalLength];
                         stats.total++;
                         if (lenPrediction === result) stats.wins++;
                     }
                 } else {
                     tempOptimalLength = updateLengthPerformanceAndFindOptimal(historyBeforeAdd, allHistory, result, { lengthPerformance: tempLengthPerformance, optimalLength: tempOptimalLength });
                 }
             }
             return tempPredictions;
         }

         function loadSession(sessionId) { 
             if (state.selectionModeActive) toggleSelectionMode();
             if (state.sessions[sessionId]) { 
                 state.currentSessionId = sessionId; 
                 state.currentPrediction = null; 
                 localStorage.setItem('lastActiveSession_v4', state.currentSessionId); 
                 updateSessionSelector(); 
                 updateAllUI(); 
             } 
         } 
          
         // --- SETTINGS --- 
         function saveSettings() { 
             const oldMode = state.settings.optimalLengthMode;
             const newSettings = { 
                 optimalLengthMode: document.getElementById('optimalLengthMode').value
             }; 
 
             // Check if the mode has changed
             if (newSettings.optimalLengthMode !== oldMode) {
                 if (confirm('B·∫°n ƒë√£ thay ƒë·ªïi ch·∫ø ƒë·ªô ghi nh·∫≠n th·ªëng k√™. B·∫°n c√≥ mu·ªën t√≠nh to√°n l·∫°i to√†n b·ªô phi√™n hi·ªán t·∫°i v·ªõi ch·∫ø ƒë·ªô m·ªõi kh√¥ng?\n\nThao t√°c n√†y s·∫Ω ghi ƒë√® l√™n th·ªëng k√™ ch√≠nh th·ª©c (T·ª∑ l·ªá th·∫Øng).')) {
                     
                     applySettings(newSettings); 
                     
                     const overlay = document.getElementById('progress-overlay');
                     overlay.classList.remove('hidden');
 
                     setTimeout(() => { 
                         try {
                             const currentSession = state.sessions[state.currentSessionId];
                             const allSessions = Object.values(state.sessions);
                             
                             const progress = {
                                 processed: 0,
                                 total: currentSession.history.length,
                                 bar: document.getElementById('progress-bar')
                             };
                             
                             reprocessSessionHistory(currentSession, allSessions, progress);
                             
                             localStorage.setItem('baccaratSettings_v1', JSON.stringify(state.settings)); 
                             saveSessions(); 
                             updateAllUI(); 
                             alert('ƒê√£ t√≠nh to√°n l·∫°i th·ªëng k√™ ch√≠nh th·ª©c v√† l∆∞u c√†i ƒë·∫∑t th√†nh c√¥ng!');
                         } catch (recalcError) {
                             alert('ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh t√≠nh to√°n l·∫°i. Vui l√≤ng ki·ªÉm tra console.');
                             console.error("Recalculation error:", recalcError);
                         } finally {
                             overlay.classList.add('hidden');
                         }
                     }, 100);
                     return; 
                 } else {
                     document.getElementById('optimalLengthMode').value = oldMode;
                     return;
                 }
             }
             
             localStorage.setItem('baccaratSettings_v1', JSON.stringify(newSettings)); 
             applySettings(newSettings); 
             alert('C√†i ƒë·∫∑t ƒë√£ ƒë∆∞·ª£c l∆∞u!'); 
         } 
 
         function applySettings(settings) { 
             if (settings.optimalLengthMode) {
                state.settings.optimalLengthMode = settings.optimalLengthMode;
             }
         } 

         function loadSettings() { 
             const settingsStr = localStorage.getItem('baccaratSettings_v1'); 
             const settings = settingsStr ? JSON.parse(settingsStr) : {}; 

             const finalSettings = {
                optimalLengthMode: 'dynamic', // Default value
                ...settings
             };
              
             applySettings(finalSettings); 

             document.getElementById('optimalLengthMode').value = state.settings.optimalLengthMode;
         } 

         // --- IMPORT / EXPORT --- 
         function exportData() { 
             if (Object.keys(state.sessions).length === 0) { 
                 alert("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t."); 
                 return; 
             } 
             const dataStr = JSON.stringify(state.sessions, null, 2); 
             const dataBlob = new Blob([dataStr], {type: "application/json"}); 
             const url = URL.createObjectURL(dataBlob); 
             const link = document.createElement('a'); 
             link.download = `baccarat_backup_${new Date().toISOString().slice(0,10)}.json`; 
             link.href = url; 
             link.click(); 
             URL.revokeObjectURL(url); 
         } 

         function importData(event) { 
             const file = event.target.files[0]; 
             if (!file) return; 
             const reader = new FileReader(); 
             reader.onload = function(e) { 
                 try { 
                     const importedSessions = JSON.parse(e.target.result); 
                     if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("Invalid format"); 
                      
                     for(const key in importedSessions) { 
                         const session = importedSessions[key]; 
                         if(!session.name || !Array.isArray(session.history)) { 
                              throw new Error("Invalid session data"); 
                         } 
                     } 

                     if (confirm('D·ªØ li·ªáu hi·ªán t·∫°i s·∫Ω b·ªã ghi ƒë√® V√Ä T√çNH TO√ÅN L·∫†I T·ª™ ƒê·∫¶U. Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t m·ªôt l√∫c v·ªõi d·ªØ li·ªáu l·ªõn. B·∫°n c√≥ ch·∫Øc mu·ªën ti·∫øp t·ª•c?')) { 
                         const overlay = document.getElementById('progress-overlay');
                         const progressBar = document.getElementById('progress-bar');
                         overlay.classList.remove('hidden');
                         progressBar.style.width = '0%';
                         progressBar.textContent = '0%';

                         setTimeout(() => {
                            try {
                                const allSessionsForReprocessing = Object.values(importedSessions);
                                const totalGamesToProcess = allSessionsForReprocessing.reduce((sum, s) => sum + (s.history ? s.history.length : 0), 0);
                                
                                const progress = {
                                    processed: 0,
                                    total: totalGamesToProcess,
                                    bar: document.getElementById('progress-bar')
                                };

                                for (const sessionId in importedSessions) {
                                    reprocessSessionHistory(importedSessions[sessionId], allSessionsForReprocessing, progress);
                                }

                                state.sessions = importedSessions; 
                                state.currentSessionId = null; 
                                localStorage.removeItem('lastActiveSession_v4'); 
                                saveSessions(); 
                                initializeApp(); 
                                
                                alert('Nh·∫≠p v√† t√≠nh to√°n l·∫°i d·ªØ li·ªáu th√†nh c√¥ng!'); 
                            } catch (recalcError) {
                                alert('ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh t√≠nh to√°n l·∫°i. Vui l√≤ng ki·ªÉm tra console ƒë·ªÉ bi·∫øt chi ti·∫øt.');
                                console.error("Recalculation error:", recalcError);
                            } finally {
                                overlay.classList.add('hidden');
                            }
                         }, 100);
                     } 
                 } catch (error) { 
                     alert('L·ªói: File d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i file.'); 
                     console.error("Import error:", error); 
                 } finally { 
                     event.target.value = ''; 
                 } 
             }; 
             reader.readAsText(file); 
         } 
 
         function reprocessSessionHistory(sessionToReprocess, allSessionsData, progress = null) {
            const originalHistory = [...(sessionToReprocess.history || [])];
            
            // Reset session stats
            sessionToReprocess.history = [];
            sessionToReprocess.predictions = []; // Official predictions
            sessionToReprocess.lengthPerformance = {};
            sessionToReprocess.optimalLength = null;

            if (progress && progress.bar) {
                progress.bar.style.width = '0%';
                progress.bar.textContent = '0%';
            }

            for (let i = 0; i < originalHistory.length; i++) {
                const result = originalHistory[i];
                const historyBeforeAdd = [...sessionToReprocess.history];
                
                // Simulate based on the OFFICIAL selected mode in settings
                const { prediction, confidence } = state.matcher.getPrediction(historyBeforeAdd, allSessionsData, {
                    optimalLength: sessionToReprocess.optimalLength,
                    lengthPerformance: sessionToReprocess.lengthPerformance
                });

                const wasPredictionCorrect = prediction === result;
                const currentOptimalLength = sessionToReprocess.optimalLength;

                if (state.settings.optimalLengthMode === 'conservative' && wasPredictionCorrect && currentOptimalLength) {
                    const pattern = historyBeforeAdd.slice(-currentOptimalLength);
                    const { prediction: lenPrediction } = state.matcher.getPredictionForPattern(pattern, allSessionsData);
                    if (lenPrediction) {
                        if (!sessionToReprocess.lengthPerformance[currentOptimalLength]) {
                            sessionToReprocess.lengthPerformance[currentOptimalLength] = { wins: 0, total: 0 };
                        }
                        const stats = sessionToReprocess.lengthPerformance[currentOptimalLength];
                        stats.total++;
                        if (lenPrediction === result) stats.wins++;
                    }
                } else {
                    const newOptimalLength = updateLengthPerformanceAndFindOptimal(
                        historyBeforeAdd, 
                        allSessionsData, 
                        result, 
                        sessionToReprocess
                    );
                    sessionToReprocess.optimalLength = newOptimalLength;
                }

                if (prediction) {
                    sessionToReprocess.predictions.push({
                        predicted: prediction,
                        actual: result,
                        confidence: confidence
                    });
                }
                
                sessionToReprocess.history.push(result);

                if (progress) {
                    progress.processed++;
                    const percent = progress.total > 0 ? Math.round((progress.processed / progress.total) * 100) : 100;
                    if (parseInt(progress.bar.textContent) !== percent) { 
                        progress.bar.style.width = `${percent}%`;
                        progress.bar.textContent = `${percent}%`;
                    }
                }
            }
        }

         function initializeApp() { 
             loadSettings(); 
             state.sessions = getSessions(); 
              
             Object.values(state.sessions).forEach(session => { 
                 if (!session.lengthPerformance) session.lengthPerformance = {}; 
                 if (session.optimalLength === undefined) session.optimalLength = null; 
                 if (session.lastPredictionConfidence === undefined) session.lastPredictionConfidence = null;
                 if (!session.predictions) session.predictions = []; // Ensure this exists for older data
             }); 

             const lastActiveId = localStorage.getItem('lastActiveSession_v4'); 

             if (Object.keys(state.sessions).length === 0) { 
                 createNewSession(); 
             } else { 
                 const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1]) - parseInt(a.split('-')[1])); 
                 const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[0]; 
                 loadSession(idToLoad); 
             } 
         } 

         // --- INITIALIZATION --- 
         document.addEventListener('DOMContentLoaded', initializeApp); 
     </script> 
 </body> 
 </html>

